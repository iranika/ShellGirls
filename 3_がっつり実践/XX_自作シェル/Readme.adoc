= 自作シェル

解説者：アキとユキ +

アキ「この章ではチープなシェルをプログラミング言語Nimで実装していきます。」 +

ユキ「初めはC言語で書かれたlshという簡易シェルを実装しようって話てたんですが、私がC言語を書いたことがないので急遽Nimを使う事になりました。」 +

アキ「Nimは優雅さを意識しているので、ソースコードも読みやすいと思います。あまりメジャーな言語とは言えませんが、私達は日頃から使い慣れているので解説しやすいと思って妥協しました。もしNimを知らない方は、この機会にNimに触れてみてください(笑)」

ユキ「私もアキにNimを布教されてから使い始めたんですよね…。まぁNimの話はこれくらいにしておいて、本題に入りましょう」　

== まずはじめに

アキ「コードの動作テストは以下の環境で確認しています。」

* macOS 
* Debian

== Nimのインストール

== さっそくコードを書く

せっかちな人のために先に書き終えたコードを紹介します。
[source, nim]
----
input:: nimsh.nim
----

以上です。 +
上記のコードで内容を理解した人は帰っても構いません。 +

このコードでも読むのが難しいと感じた人のために、以降はどのように実装したのか開発スタイルや過程も含めて説明していきます。

=== 開発スタイルについて

今回の開発ではBDD？のようなissue駆動開発？っぽい感じで進めていきます。

. 振る舞いについてのissueを作成
. issue通りに振る舞うようにコードを改良する。
. テストする(手動orテストコード)

？がついているのは私が開発手法について詳しくないので、このような開発手法をなんと呼ぶのが正確なのかわからないからです。 +
BDDに区分されるような気がするのですが、テストコードを必ず書くわけではありません。 +
このスタイルは、動くアプリケーションを作ることを最重要視しているため、テストコードなどアプリケーションの動作に直接かかわらないコードの重要度が低いのが特徴です。 +
このやり方はテストコードをあまり書かない分、開発速度が早いです。 +
また場合によっては機能の追加などに迅速に対応できます。 +
品質保証を犠牲にしてでも、開発スピードを重視したいケースーープロトタイプの実装でよく使います。 +
今回は趣味プログラミングなので、品質保証は犠牲にしていきます。

=== 最初の仕様

まずシェルの振る舞いについて分析してみます。シェルを起動してから、終了するまでの処理について知っている範囲でアバウトに考えてみます(この時点で例外は考えません)

. 初期化処理：初期化処理が走る(内部変数などの初期化)
. ループ処理：入力受付と入力解析と実行を繰り返す
.. 入力受付：プロンプトが表示され入力を受け付ける
.. 入力解析：入力された内容を解析する
.. 解析内容の実行：解析内容から何かしら処理を実行する
... コマンドの実行
... シェルの終了

シェルの終了(例えばexit)は「入力を解析して何かしら処理する」部分での振る舞いなので「入力解析と実行」の処理として、入れ子にしています。

ここで注意なのですが、これはアバウトに考えた内容なので最適化されていません。ですので、この仕様は今後頻繁に変わることがあります。
とりあえずこれをVer0.1仕様と呼ぶことにします。

=== 実装を始める前に

今回はCLIアプリケーションの実装なので、cligenというパッケージを使うことにします。  
Ver0.1の仕様だとcligenを使う必要がないのですが、cligenのdispatchを使っておけばシェル自体のヘルプ実装などが楽になるので、今後のためにとりあえず使えるようにしておきます。

[source, nim]
----
<ここにコードを書く>
----

このようにdispatchを間に噛ませておくことで、mainの呼び出し前にdispatchでバリデーションができます。
isMainModule → dispatch → main
もしかしたら使わないかもしれませんが、削除するときはdispatchを経由しないようにすればいいだけなのでとりあえず使うことにします。

=== 初期化処理の実装
さてそれでは、Ver0.1仕様のトップレベルにある初期化処理から実装していきます。
今の所、起動時に初期化したい内部変数などは無いのでとりあえずなにか文字列でも表示させてみます。
こんな感じでしょうか。

[source, nim]
----
<ここにコードを書く>
----

ビルドして実行してみると、初期化処理の関数が呼び出されて文字列が出力されて終了します。
とりあえず初期実装が終わりました。
これから、初期化処理で実行したい処理が出てきたら、この関数に記述していけば良さそうですね。

=== ループ処理の実装

さて、一番厄介そうなループ処理の実装です。
ループでは入力受付、入力解析、解析内容の実行を行います。
ただ、一気に実装するのは大変なのでマイルストーンをおいて、少しずつ機能を実装していきましょう。

マイルストーンはこんな感じに設定しました。

. 
. 入力された文字列を表示する。この処理をループする。(とりあえず終了はCtrl+Cで)
. 入力された文字列を解析して、意味のあるデータ構造(args)にする
. argsを読み取って、何かしらの処理を実行する
. 

2と3の詳細についてはおいおい考えるとして、まずは1に専念します。

[source, nim]
----
<ここにコードを書く>
----

ビルドして実行してみると、入力を受け付けるようになりました。
受け付けた入力は、入力解析に渡されて出力されています。
入力を受け付けるようになっただけで、なんだかシェルっぽく見えますね。
…あっ！！
このプログラムは、入力を受け付けて出力する行為を永遠に繰り返してしまいます。。。
終了するには、Ctrl＋Cで終了してください。。。

=== 入力解析の実装

入力解析を実装していきます。
簡易シェルなので、とりあえず以下の構文をサポートすることにします。

----
<command> [arg1] [arg2] [arg3] ....
----

シェルでよくサポートされている構文ですね。
この文字列なら空白(スペース)で分割して、Stringの配列 argsにすればargs[0]がコマンド、args[1..]が引数として扱えます。
CLIのプログラムを書いたことがある人は見覚えがある構造だと思います。
独自の構造体を定義してもいいのですが、ここは先人達の作った文化を継承することにしましよう。

こんな感じでどうでしょうか。

[source, nim]
----
<ここにコードを書く>
----

ビルドして実行してみたら、以下を入力してみましょう。

簡易的ですが、これで入力内容が意味のあるデータ構造になりました。

=== 解析内容の実行


== 余談
<ここに余談を書く>

== 用語解説
<出てきた用語>:: <用語の説明をここに書く>